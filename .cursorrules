# Chopstack Project Rules

## Project Overview

**chopstack** is a TypeScript CLI tool and MCP (Model Context Protocol) server that helps chop massive AI changes into clean, reviewable PR stacks using AI-powered parallel Git workflows with intelligent task decomposition.

This project has a dual-purpose architecture:

1. **CLI Tool** (`src/bin/chopstack.ts`): Standalone command-line interface for chopstack operations
2. **MCP Server** (`src/index.ts`): Model Context Protocol server for AI integration

## Development Commands

### Building and Development

```bash
# Build the project
pnpm run build

# Watch mode development (CLI)
pnpm run dev

# Watch mode development (library)
pnpm run dev:lib

# MCP server development
pnpm run dev:mcp

# Inspect MCP server
pnpm run inspect:mcp
```

### Code Quality and Testing

```bash
# Run linting
pnpm run lint

# Fix linting issues automatically
pnpm run lint:fix

# Type checking
pnpm run type-check

# Format code
pnpm run format

# Check formatting
pnpm run format:check

# Tests
pnpm run test           # All tests (unit + E2E + execution)
pnpm run test:unit      # Unit tests only
pnpm run test:e2e       # E2E integration tests
pnpm run test:execution # Execution planning tests
```

### Running the CLI

```bash
# Run built CLI
pnpm run start

# Run MCP server
pnpm run start:mcp

# Clean build artifacts
pnpm run clean
```

## Architecture Overview

### Core Components

- **Parser** (`src/parser/spec-parser.ts`): Parses markdown specifications into structured tasks with dependencies, files, priorities, and complexity estimates
- **Types** (`src/types/decomposer.ts`): Core type definitions for tasks, DAG nodes, conflict resolution, and specifications
- **MCP Server** (`src/mcp/server.ts`): FastMCP server with task orchestration tools
- **Task Orchestrator** (`src/mcp/orchestrator.ts`): Manages parallel task execution using Claude Code CLI in plan mode
- **Execution Testing** (`test/execution/`): Tests Claude's execution planning using `--permission-mode plan`
- **Build System**: Uses `tsup` for ESM-only builds targeting Node.js 18+ with dual entry points

### Key Design Patterns

The codebase follows these architectural patterns:

1. **Functional Pattern Matching**: Uses `ts-pattern` extensively for control flow instead of switch/if-else chains
2. **Type-First Design**: Leverages Zod schemas for runtime validation, especially for MCP integration
3. **ESM-Only**: Built as ESM modules using latest TypeScript and Node.js features
4. **Strict TypeScript**: All strict compiler options enabled with comprehensive type safety

## Technology Stack

- **Runtime**: Node.js >=18.0.0 with ESM modules
- **Language**: TypeScript with very strict configuration
- **Package Manager**: pnpm (required)
- **Build Tool**: tsup for fast ESM builds
- **MCP Framework**: FastMCP (built on official MCP SDK)
- **Pattern Matching**: ts-pattern for functional control flow
- **Validation**: Zod for schema validation and runtime type checking
- **External Types**: Official Claude Code SDK types from `@anthropic-ai/claude-code`
- **Testing**: Jest for unit/E2E tests, custom execution testing framework

## Code Style & Patterns

### TypeScript Guidelines

- Use `type` over `interface` for simple shapes
- All public functions must have explicit return types
- Use `const assertions` and `as const` for immutable data
- Import file extensions are omitted (handled by build system)
- Strict naming: camelCase for functions, PascalCase for types, kebab-case for files
- **ALWAYS use `utils/guards.ts`** for type guards instead of inline checks:
  - `isNonEmptyString()` for non-empty string checks
  - `isNonNullish()` for null/undefined checks
  - `hasContent()` for strings with actual content
  - `isValidArray()` for non-empty arrays
  - `isNonEmptyObject()` for objects with properties
- Follow `@typescript-eslint/naming-convention` including leading underscore for private members
- Avoid non-null assertions (`!`) and use `isNonNullish()` instead

### Pattern Matching with ts-pattern

- **ALWAYS use ts-pattern for complex conditional logic** instead of switch statements or if/else chains
- Import: `import { match, P } from 'ts-pattern'`
- Use `match()` for:
  - Handling different CLI command types
  - Processing different Git operation results
  - Handling various error states
  - Parsing different configuration formats
  - State machine transitions

#### ts-pattern Examples:

```typescript
// CLI command handling
const result = match(command)
  .with({ type: 'init' }, (cmd) => handleInit(cmd))
  .with({ type: 'stack' }, (cmd) => handleStack(cmd))
  .with({ type: 'review' }, (cmd) => handleReview(cmd))
  .exhaustive();

// Error handling
const response = match(error)
  .with({ code: 'ENOENT' }, () => 'File not found')
  .with({ code: P.string.startsWith('EACCES') }, () => 'Permission denied')
  .with(P.instanceOf(GitError), (err) => `Git error: ${err.message}`)
  .otherwise(() => 'Unknown error');

// State transitions
const nextState = match([currentState, action])
  .with(['idle', { type: 'start' }], () => 'processing')
  .with(['processing', { type: 'complete' }], () => 'done')
  .with(['processing', { type: 'error' }], () => 'failed')
  .otherwise(() => currentState);
```

### Code Organization

- **Barrel exports**: Use `index.ts` files to create clean public APIs
- **Single responsibility**: Each module should have one clear purpose
- **Functional approach**: Prefer pure functions, avoid mutations
- **Error handling**: Use Result types or proper error boundaries
- **CLI structure**: Keep CLI logic separate from core business logic

### Naming Conventions

- **Files**: kebab-case (`git-operations.ts`, `pr-stack.ts`)
- **Functions**: camelCase, descriptive verbs (`parseGitStatus`, `createPrStack`)
- **Types**: PascalCase (`CliCommand`, `GitOperation`, `PrStackConfig`)
- **Constants**: SCREAMING_SNAKE_CASE (`DEFAULT_BRANCH`, `MAX_STACK_SIZE`)
- **Enums**: PascalCase with descriptive values

### Import Organization

Always use extensionless imports; do not specify the file extension in imports.

The ESLint configuration enforces this import order:

1. Node.js built-ins (using `node:` protocol)
2. External dependencies
3. Internal imports

```typescript
// 1. Node.js built-ins
import { readFile } from 'node:fs/promises';
import { join } from 'node:path';

// 2. External dependencies
import { FastMCP } from 'fastmcp';
import { match } from 'ts-pattern';
import { z } from 'zod';

// 3. Internal imports (absolute paths preferred)
import { GitOperations } from './git-operations';
import { type CliCommand } from './types';
```

### Code Quality Standards

- **Very Strict TypeScript**: All strict flags enabled, no `any`, explicit function return types required
- **No Default Exports**: Use named exports throughout (except for config files)
- **Pattern Exhaustiveness**: All pattern matches must be exhaustive
- **Modern JavaScript**: Prefer modern APIs, avoid legacy patterns
- **Functional Approach**: Pure functions preferred, avoid mutations where possible

## Development Practices

### Error Handling

- Use ts-pattern for error matching and handling
- Create specific error types for different failure modes
- Always provide helpful error messages for CLI users
- Log errors appropriately (use structured logging)

### Testing Strategy

- Write unit tests for core business logic
- Use integration tests for CLI commands
- Mock external dependencies (Git, file system)
- Test error scenarios thoroughly

### Git & Version Control

- Use conventional commits
- Keep commits focused and atomic
- Write descriptive commit messages
- Use feature branches for new functionality

### Performance Considerations

- Use incremental TypeScript compilation
- Lazy load heavy dependencies when possible
- Consider streaming for large file operations
- Profile Git operations for bottlenecks

## CLI-Specific Guidelines

### Command Structure

- Use consistent command naming and structure
- Provide helpful `--help` output for all commands
- Support both short (`-h`) and long (`--help`) flags
- Validate input early and provide clear error messages

### User Experience

- Show progress indicators for long operations
- Provide clear success/failure feedback
- Use colors and formatting for better readability
- Support both interactive and non-interactive modes

### Configuration

- Support multiple configuration sources (CLI flags, config files, env vars)
- Use sensible defaults
- Validate configuration and show clear error messages
- Document all configuration options

## Execution Testing Framework

The project includes a unique execution testing framework that validates Claude's task execution approach without expensive API calls:

### How It Works

1. **Plan Generation**: Uses `chopstack decompose` to generate task DAGs from markdown specs
2. **Execution Planning**: Tests each task using `claude --permission-mode plan` to get execution plans
3. **Quality Analysis**: Analyzes plans for complexity, file operations, technical accuracy, and completeness
4. **Cost Efficiency**: ~$0.10-0.20 per task vs $2-5+ for full implementation testing

### Key Components

- **ExecutionPlanAnalyzer** (`src/utils/execution-plan-analyzer.ts`): Uses official Claude Code SDK types
- **TaskOrchestrator** (`src/mcp/orchestrator.ts`): Enhanced with `planMode` parameter
- **Test Suite** (`test/execution/plan-execution.test.ts`): Comprehensive execution planning validation

### Usage

```bash
# Run execution tests only
pnpm run test:execution

# Tests validate:
# - Plan structure and quality (0-100 score)
# - Technical detail accuracy
# - File operation mapping
# - Technology detection (React, TypeScript, etc.)
# - Comparative analysis across tasks
```

## FastMCP Integration

The project uses FastMCP for simplified MCP server development:

- Leverages Zod schemas with FastMCP's Standard Schema support
- Use `fastmcp dev src/index.ts` for development
- Use `fastmcp inspect src/index.ts` to inspect the server
- Built-in session management and error handling

### FastMCP Patterns

```typescript
// Server setup
const server = new FastMCP({
  name: 'chopstack',
  version: '0.1.0',
  instructions: 'AI-powered Git workflow automation tool',
});

// Tool definition with Zod validation
server.addTool({
  name: 'create-pr-stack',
  description: 'Create a stack of PRs from changes',
  parameters: z.object({
    baseBranch: z.string().default('main'),
    maxStackSize: z.number().min(1).max(10).default(5),
  }),
  execute: async (args, { session }) => {
    return match(args)
      .with({ baseBranch: P.string }, (params) => createStack(params))
      .exhaustive();
  },
});

// Start server with appropriate transport
server.start({
  transportType: 'stdio', // For CLI integration
  // transportType: "httpStream", // For HTTP/SSE
});
```

## File Structure

```
src/
├── bin/           # CLI entry points
├── agents/        # Agent implementations (Claude, Aider, Mock)
├── commands/      # CLI command implementations
├── mcp/           # MCP server and task orchestration
├── parser/        # Spec parsing logic
├── types/         # TypeScript type definitions
├── utils/         # Utility functions and guards
└── index.ts       # Main MCP server export

test/
├── e2e/           # End-to-end integration tests
├── execution/     # Execution planning tests (using --permission-mode plan)
└── unit/          # Unit tests (if any)
```

## Code Review Guidelines

- Ensure all pattern matching is exhaustive
- Check for proper error handling
- Verify TypeScript types are precise
- Confirm CLI UX is intuitive
- Test with real Git repositories

## Documentation

- Use JSDoc for public APIs
- Include usage examples in README
- Document complex algorithms and business logic
- Keep inline comments focused on "why" not "what"

## Dependencies

- Minimize external dependencies
- Prefer well-maintained, popular packages
- Keep dev dependencies up to date
- Use exact versions for critical dependencies

## Development Notes

- Package manager is strictly pnpm (not npm or yarn)
- Build targets Node.js 18+ with ESM-only output
- Uses incremental TypeScript builds for performance
- ESLint configuration is very strict with comprehensive rules for TypeScript, imports, and code quality
- Uses official Claude Code SDK types from `@anthropic-ai/claude-code` package
- README.md is minimal (placeholder), main documentation is in .cursorrules

Remember: This is a developer tool, so prioritize developer experience, clear error messages, and robust Git integration.
