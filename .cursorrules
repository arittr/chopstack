# Chopstack Project Rules

## Project Overview
This is a TypeScript CLI tool called "chopstack" that helps chop massive AI changes into clean, reviewable PR stacks using AI-powered parallel Git workflows with intelligent task decomposition.

## Technology Stack
- **Language**: TypeScript (ES2022, NodeNext modules)
- **Runtime**: Node.js >=18.0.0
- **Package Manager**: pnpm
- **Key Dependencies**: 
  - `fastmcp` for MCP server framework (built on official MCP SDK)
  - `ts-pattern` for functional pattern matching
  - `zod` for schema validation (works with FastMCP's Standard Schema support)
- **Build**: TypeScript compiler with incremental builds
- **Linting**: ESLint with TypeScript rules, Prettier for formatting

## Code Style & Patterns

### TypeScript Guidelines
- Use strict TypeScript configuration (all strict flags enabled)
- Prefer `type` over `interface` for simple shapes
- Use `interface` for extensible object shapes and when declaration merging might be needed
- Always use explicit return types for public functions
- Use `const assertions` and `as const` for immutable data
- Leverage TypeScript's advanced types: union types, mapped types, conditional types

### Pattern Matching with ts-pattern
- **ALWAYS use ts-pattern for complex conditional logic** instead of switch statements or if/else chains
- Import: `import { match, P } from 'ts-pattern'`
- Use `match()` for:
  - Handling different CLI command types
  - Processing different Git operation results  
  - Handling various error states
  - Parsing different configuration formats
  - State machine transitions

#### ts-pattern Examples:
```typescript
// CLI command handling
const result = match(command)
  .with({ type: 'init' }, (cmd) => handleInit(cmd))
  .with({ type: 'stack' }, (cmd) => handleStack(cmd))
  .with({ type: 'review' }, (cmd) => handleReview(cmd))
  .exhaustive();

// Error handling
const response = match(error)
  .with({ code: 'ENOENT' }, () => 'File not found')
  .with({ code: P.string.startsWith('EACCES') }, () => 'Permission denied')
  .with(P.instanceOf(GitError), (err) => `Git error: ${err.message}`)
  .otherwise(() => 'Unknown error');

// State transitions
const nextState = match([currentState, action])
  .with(['idle', { type: 'start' }], () => 'processing')
  .with(['processing', { type: 'complete' }], () => 'done')
  .with(['processing', { type: 'error' }], () => 'failed')
  .otherwise(() => currentState);
```

### Code Organization
- **Barrel exports**: Use `index.ts` files to create clean public APIs
- **Single responsibility**: Each module should have one clear purpose
- **Functional approach**: Prefer pure functions, avoid mutations
- **Error handling**: Use Result types or proper error boundaries
- **CLI structure**: Keep CLI logic separate from core business logic

### Naming Conventions
- **Files**: kebab-case (`git-operations.ts`, `pr-stack.ts`)
- **Functions**: camelCase, descriptive verbs (`parseGitStatus`, `createPrStack`)
- **Types**: PascalCase (`CliCommand`, `GitOperation`, `PrStackConfig`)
- **Constants**: SCREAMING_SNAKE_CASE (`DEFAULT_BRANCH`, `MAX_STACK_SIZE`)
- **Enums**: PascalCase with descriptive values

### Import Organization
```typescript
// 1. Node.js built-ins
import { readFile } from 'node:fs/promises';
import { join } from 'node:path';

// 2. External dependencies  
import { FastMCP } from 'fastmcp';
import { match } from 'ts-pattern';
import { z } from 'zod';

// 3. Internal imports (absolute paths preferred)
import { GitOperations } from './git-operations.js';
import { type CliCommand } from './types.js';
```

## Development Practices

### Error Handling
- Use ts-pattern for error matching and handling
- Create specific error types for different failure modes
- Always provide helpful error messages for CLI users
- Log errors appropriately (use structured logging)

### Testing Strategy
- Write unit tests for core business logic
- Use integration tests for CLI commands
- Mock external dependencies (Git, file system)
- Test error scenarios thoroughly

### Git & Version Control
- Use conventional commits
- Keep commits focused and atomic
- Write descriptive commit messages
- Use feature branches for new functionality

### Performance Considerations
- Use incremental TypeScript compilation
- Lazy load heavy dependencies when possible
- Consider streaming for large file operations
- Profile Git operations for bottlenecks

## CLI-Specific Guidelines

### Command Structure
- Use consistent command naming and structure
- Provide helpful `--help` output for all commands
- Support both short (`-h`) and long (`--help`) flags
- Validate input early and provide clear error messages

### User Experience
- Show progress indicators for long operations
- Provide clear success/failure feedback
- Use colors and formatting for better readability
- Support both interactive and non-interactive modes

### Configuration
- Support multiple configuration sources (CLI flags, config files, env vars)
- Use sensible defaults
- Validate configuration and show clear error messages
- Document all configuration options

## FastMCP Integration
- Use FastMCP's simplified API for MCP server development
- Leverage Zod schemas with FastMCP's Standard Schema support
- Use FastMCP's built-in session management and authentication
- Take advantage of FastMCP's automatic error handling and logging
- Use FastMCP's CLI tools for development and testing (`fastmcp dev`, `fastmcp inspect`)

### FastMCP Patterns
```typescript
// Server setup
const server = new FastMCP({
  name: "chopstack",
  version: "0.1.0",
  instructions: "AI-powered Git workflow automation tool",
});

// Tool definition with Zod validation
server.addTool({
  name: "create-pr-stack",
  description: "Create a stack of PRs from changes",
  parameters: z.object({
    baseBranch: z.string().default("main"),
    maxStackSize: z.number().min(1).max(10).default(5),
  }),
  execute: async (args, { session }) => {
    return match(args)
      .with({ baseBranch: P.string }, (params) => createStack(params))
      .exhaustive();
  },
});

// Start server with appropriate transport
server.start({
  transportType: "stdio", // For CLI integration
  // transportType: "httpStream", // For HTTP/SSE
});
```

## File Structure Preferences
```
src/
├── bin/           # CLI entry points
├── commands/      # Individual CLI commands
├── core/          # Core business logic
├── git/           # Git operations
├── mcp/           # MCP integration
├── types/         # Type definitions
├── utils/         # Utility functions
└── index.ts       # Main library export
```

## Code Review Guidelines
- Ensure all pattern matching is exhaustive
- Check for proper error handling
- Verify TypeScript types are precise
- Confirm CLI UX is intuitive
- Test with real Git repositories

## Documentation
- Use JSDoc for public APIs
- Include usage examples in README
- Document complex algorithms and business logic
- Keep inline comments focused on "why" not "what"

## Dependencies
- Minimize external dependencies
- Prefer well-maintained, popular packages
- Keep dev dependencies up to date
- Use exact versions for critical dependencies

Remember: This is a developer tool, so prioritize developer experience, clear error messages, and robust Git integration.
