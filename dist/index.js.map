{
  "version": 3,
  "sources": ["../src/entry/mcp/server.ts", "../src/entry/mcp/tools/vcs-tools.ts", "../src/index.ts"],
  "sourcesContent": [
    "import { execa } from 'execa';\nimport { FastMCP } from 'fastmcp';\nimport { z } from 'zod';\n\nimport {\n  ClaudeCliTaskExecutionAdapter,\n  type StreamingUpdate,\n  TaskOrchestrator,\n} from '@/services/orchestration';\n\nimport { registerVcsTools } from './tools/vcs-tools';\n\n// Schema definitions\nconst ExecuteTaskSchema = z.object({\n  taskId: z.string().describe('Unique identifier for the task'),\n  title: z.string().describe('Human-readable task title'),\n  prompt: z.string().describe('The prompt to send to Claude Code'),\n  files: z.array(z.string()).describe('List of files relevant to this task'),\n  strategy: z.enum(['serial', 'parallel']).describe('Execution strategy'),\n  workdir: z.string().optional().describe('Working directory for parallel tasks'),\n});\n\nconst ParallelTaskSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  prompt: z.string(),\n  files: z.array(z.string()),\n});\n\nconst ExecuteParallelTasksSchema = z.object({\n  tasks: z.array(ParallelTaskSchema).describe('Array of tasks to execute in parallel'),\n  baseRef: z.string().describe('Git reference to branch from'),\n});\n\n// Create MCP server\nconst mcp = new FastMCP({\n  name: 'chopstack-orchestrator',\n  version: '1.0.0',\n});\nconst orchestrator = new TaskOrchestrator(new ClaudeCliTaskExecutionAdapter());\n\n// Register VCS tools (they create their own VcsEngineService instances as needed)\nregisterVcsTools(mcp);\n\n// Store streaming updates for retrieval\nconst taskUpdates: Map<string, StreamingUpdate[]> = new Map();\n\n// Listen to orchestrator events\norchestrator.on('taskUpdate', (update: StreamingUpdate) => {\n  if (!taskUpdates.has(update.taskId)) {\n    taskUpdates.set(update.taskId, []);\n  }\n  taskUpdates.get(update.taskId)?.push(update);\n});\n\n// Register tools\nmcp.addTool({\n  name: 'execute_task',\n  description: 'Execute a single task with git workflow (serial or parallel)',\n  parameters: ExecuteTaskSchema,\n  execute: async (params) => {\n    const { taskId, title, prompt, files, strategy, workdir } = params;\n\n    try {\n      if (strategy === 'parallel') {\n        // For parallel, ensure we have a worktree\n        // TODO: Update to use VcsEngine instead of removed orchestrator methods\n        const actualWorkdir = workdir ?? process.cwd();\n        const result = await orchestrator.executeTask(taskId, title, prompt, files, actualWorkdir);\n\n        // TODO: Implement commit changes using VcsEngine\n        // if (result.status === 'completed') {\n        //   await vcsEngine.commitTaskChanges(...);\n        // }\n\n        return JSON.stringify(result);\n      }\n      // Serial execution in current directory\n      const result = await orchestrator.executeTask(taskId, title, prompt, files);\n\n      // Commit changes for serial execution\n      if (result.status === 'completed') {\n        await execa('git', ['add', '-A']);\n        await execa('git', ['commit', '-m', title]);\n      }\n\n      return JSON.stringify(result);\n    } catch (error) {\n      return JSON.stringify({\n        taskId,\n        status: 'failed',\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  },\n});\n\nmcp.addTool({\n  name: 'execute_parallel_tasks',\n  description: 'Execute multiple tasks in parallel using git worktrees',\n  parameters: ExecuteParallelTasksSchema,\n  // eslint-disable-next-line @typescript-eslint/require-await -- temporary stub\n  execute: async () => {\n    // TODO: Update to use VcsEngine for parallel execution\n    // For now, return a message indicating this is disabled\n    return JSON.stringify({\n      message: 'Parallel execution temporarily disabled - needs VcsEngine integration',\n    });\n  },\n});\n\nmcp.addTool({\n  name: 'list_running_tasks',\n  description: 'List all currently running tasks',\n  parameters: z.object({}),\n  execute: async () => {\n    // MCP tools must be async\n    await Promise.resolve();\n\n    const runningTasks = orchestrator.getRunningTasks();\n    const statuses = orchestrator.getAllTaskStatuses();\n\n    return JSON.stringify({\n      running: runningTasks,\n      allStatuses: Object.fromEntries(statuses),\n    });\n  },\n});\n\nmcp.addTool({\n  name: 'stop_task',\n  description: 'Stop a running task',\n  parameters: z.object({\n    taskId: z.string().describe('Task ID to stop'),\n  }),\n  execute: async (params) => {\n    // MCP tools must be async\n    await Promise.resolve();\n    const stopped = orchestrator.stopTask(params.taskId);\n    return JSON.stringify({\n      taskId: params.taskId,\n      stopped,\n    });\n  },\n});\n\nmcp.addTool({\n  name: 'get_task_output',\n  description: 'Get the output of a task',\n  parameters: z.object({\n    taskId: z.string().describe('Task ID to get output for'),\n  }),\n  execute: async (params) => {\n    // MCP tools must be async\n    await Promise.resolve();\n    const output = orchestrator.getTaskOutput(params.taskId);\n    const status = orchestrator.getTaskStatus(params.taskId);\n\n    return JSON.stringify({\n      taskId: params.taskId,\n      status,\n      output,\n    });\n  },\n});\n\nmcp.addTool({\n  name: 'get_task_updates',\n  description: 'Get streaming updates for a task',\n  parameters: z.object({\n    taskId: z.string().describe('Task ID to get updates for'),\n    since: z.number().optional().describe('Timestamp to get updates since (milliseconds)'),\n  }),\n  execute: async (params) => {\n    // MCP tools must be async\n    await Promise.resolve();\n\n    const updates = taskUpdates.get(params.taskId) ?? [];\n\n    if (params.since !== undefined && params.since !== 0) {\n      const sinceDate = new Date(params.since);\n      return JSON.stringify({\n        taskId: params.taskId,\n        updates: updates.filter((u) => u.timestamp > sinceDate),\n      });\n    }\n\n    return JSON.stringify({\n      taskId: params.taskId,\n      updates,\n    });\n  },\n});\n\n// Start the MCP server with stdio transport\nvoid mcp.start({\n  transportType: 'stdio',\n});\n\n// Export the server as named export\nexport { mcp };\n",
    "/**\n * VCS MCP Tools\n *\n * Exposes VCS operations through MCP tools for VCS-agnostic worktree management.\n * These tools provide primitives for:\n * - VCS mode configuration and validation\n * - Isolated worktree creation for parallel task execution\n * - Stack integration with mode-specific behavior\n * - Worktree cleanup and lifecycle management\n *\n * Design: Thin adapters that delegate to VCS domain services.\n * No business logic - all operations handled by VcsConfigService and VcsEngineService.\n */\n\nimport type { FastMCP } from 'fastmcp';\n\nimport type {\n  CleanupWorktreeParams,\n  ConfigureVcsParams,\n  CreateWorktreeParams,\n  IntegrateStackParams,\n  ListWorktreesParams,\n} from '@/entry/mcp/schemas/vcs-schemas';\n\nimport {\n  CleanupWorktreeSchema,\n  ConfigureVcsSchema,\n  CreateWorktreeSchema,\n  IntegrateStackSchema,\n  ListWorktreesSchema,\n} from '@/entry/mcp/schemas/vcs-schemas';\nimport { VcsConfigServiceImpl } from '@/services/vcs/vcs-config';\nimport { VcsEngineServiceImpl } from '@/services/vcs/vcs-engine-service';\nimport { logger } from '@/utils/global-logger';\n\n/**\n * Register all VCS MCP tools with FastMCP server\n *\n * Registers 5 VCS tools:\n * 1. configure_vcs - VCS mode configuration and validation\n * 2. create_task_worktree - Isolated worktree creation\n * 3. integrate_task_stack - Mode-specific stack integration\n * 4. cleanup_task_worktree - Worktree cleanup\n * 5. list_task_worktrees - List active worktrees\n *\n * @param mcp - FastMCP server instance\n */\nexport function registerVcsTools(mcp: FastMCP): void {\n  // Tool 1: Configure VCS mode\n  mcp.addTool({\n    name: 'configure_vcs',\n    description:\n      'Configure VCS mode and verify tool availability. ' +\n      'Validates that the requested VCS backend is installed and functional. ' +\n      'If mode is omitted, defaults to merge-commit (requires only git). ' +\n      'Explicit mode failures provide installation instructions.',\n    parameters: ConfigureVcsSchema,\n    execute: async (params: ConfigureVcsParams) => {\n      try {\n        logger.debug('configure_vcs called', { params });\n\n        // Create VCS config service\n        const configService = new VcsConfigServiceImpl();\n\n        // Use explicit mode or default to merge-commit\n        const mode = params.mode ?? 'merge-commit';\n        const explicitMode = params.mode !== undefined;\n\n        logger.info(`Configuring VCS mode: ${mode} (explicit: ${explicitMode})`);\n\n        // Load configuration (merges CLI params with file config)\n        await configService.loadConfig(params.workdir, mode);\n\n        // Validate mode availability\n        const validatedMode = await configService.validateMode(mode, explicitMode);\n\n        // Create and initialize backend\n        const backend = await configService.createBackend(validatedMode, params.workdir);\n        const available = await backend.isAvailable();\n\n        if (!available) {\n          // If explicit mode requested, fail immediately with installation instructions\n          if (explicitMode) {\n            const error =\n              `VCS tool for mode '${mode}' not found. ` +\n              `Install required tools or change configuration.`;\n\n            logger.error(error);\n\n            return JSON.stringify({\n              status: 'failed',\n              mode,\n              available: false,\n              error,\n            });\n          }\n\n          // Default mode (merge-commit) should always be available if git exists\n          const gitError = 'Git not found. Please install git to use chopstack.';\n          logger.error(gitError);\n\n          return JSON.stringify({\n            status: 'failed',\n            error: gitError,\n          });\n        }\n\n        // Initialize backend with working directory and trunk\n        await backend.initialize(params.workdir, params.trunk);\n\n        logger.info(`VCS backend initialized: ${validatedMode}`, {\n          workdir: params.workdir,\n          trunk: params.trunk,\n        });\n\n        // Determine capabilities based on mode\n        const supportsStacking = ['git-spice', 'graphite', 'sapling', 'stacked'].includes(\n          validatedMode,\n        );\n        const supportsParallel = true; // All modes support parallel execution\n\n        return JSON.stringify({\n          status: 'success',\n          mode: validatedMode,\n          available: true,\n          capabilities: {\n            supportsStacking,\n            supportsParallel,\n          },\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.error('configure_vcs failed', { error: errorMessage });\n\n        return JSON.stringify({\n          status: 'failed',\n          error: errorMessage,\n        });\n      }\n    },\n  });\n\n  // Tool 2: Create task worktree\n  mcp.addTool({\n    name: 'create_task_worktree',\n    description:\n      'Create isolated worktree for task execution with unique branch. ' +\n      'Each task gets its own workspace, preventing file conflicts in parallel execution. ' +\n      'Returns worktree path, branch name, and base reference for agent setup.',\n    parameters: CreateWorktreeSchema,\n    execute: async (params: CreateWorktreeParams) => {\n      try {\n        logger.debug('create_task_worktree called', { params });\n\n        // Get working directory (default to current directory)\n        const workdir = params.workdir ?? process.cwd();\n\n        // Create VCS engine service with default configuration\n        const vcsEngine = new VcsEngineServiceImpl({\n          branchPrefix: 'task',\n          shadowPath: '.chopstack/shadows',\n          cleanupOnSuccess: true,\n          cleanupOnFailure: false,\n          conflictStrategy: 'fail',\n          stackSubmission: {\n            enabled: false,\n            draft: false,\n            autoMerge: false,\n          },\n        });\n        await vcsEngine.initialize(workdir);\n\n        logger.info(`Creating worktree for task ${params.taskId} from ${params.baseRef}`);\n\n        // Create minimal execution task structure for VcsEngineService\n        const executionTask = {\n          id: params.taskId,\n          name: params.task?.name ?? params.taskId,\n          complexity: 'M' as const,\n          description: params.task?.name ?? params.taskId,\n          files: params.task?.files ?? [],\n          acceptanceCriteria: [],\n          dependencies: [],\n          maxRetries: 0,\n          retryCount: 0,\n          state: 'pending' as const,\n          stateHistory: [],\n        };\n\n        // Create worktree using VcsEngineService\n        const worktrees = await vcsEngine.createWorktreesForTasks(\n          [executionTask],\n          params.baseRef,\n          workdir,\n        );\n\n        if (worktrees.length === 0) {\n          throw new Error('Failed to create worktree: no worktree context returned');\n        }\n\n        const worktree = worktrees[0];\n\n        if (worktree === undefined) {\n          throw new Error('Worktree context is undefined');\n        }\n\n        logger.info('Worktree created successfully', {\n          taskId: worktree.taskId,\n          branch: worktree.branchName,\n          path: worktree.absolutePath,\n        });\n\n        return JSON.stringify({\n          status: 'success',\n          taskId: params.taskId,\n          path: worktree.worktreePath,\n          absolutePath: worktree.absolutePath,\n          branch: worktree.branchName,\n          baseRef: params.baseRef,\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.error('create_task_worktree failed', { error: errorMessage, taskId: params.taskId });\n\n        // Check for common error patterns and provide actionable guidance\n        let actionableError = errorMessage;\n        if (errorMessage.includes('already exists') || errorMessage.includes('collision')) {\n          actionableError =\n            `Branch name collision for task '${params.taskId}'. ` +\n            `The branch or worktree already exists. ` +\n            `Clean up with: git worktree remove .chopstack/shadows/${params.taskId} && ` +\n            `git branch -d task/${params.taskId}`;\n        }\n\n        return JSON.stringify({\n          status: 'failed',\n          taskId: params.taskId,\n          error: actionableError,\n        });\n      }\n    },\n  });\n\n  // Tool 3: Integrate task stack\n  mcp.addTool({\n    name: 'integrate_task_stack',\n    description:\n      'Integrate completed task branches into stack based on VCS mode. ' +\n      'Handles mode-specific stack integration (git-spice restacking, merge-commit merges). ' +\n      'Detects and reports merge conflicts with resolution steps. ' +\n      'Optionally submits stack for review (creates PRs).',\n    parameters: IntegrateStackSchema,\n    execute: async (params: IntegrateStackParams) => {\n      try {\n        logger.debug('integrate_task_stack called', { params });\n\n        // Get working directory (default to current directory)\n        const workdir = params.workdir ?? process.cwd();\n\n        // Create VCS engine service with default configuration\n        const vcsEngine = new VcsEngineServiceImpl({\n          branchPrefix: 'task',\n          shadowPath: '.chopstack/shadows',\n          cleanupOnSuccess: true,\n          cleanupOnFailure: false,\n          conflictStrategy: 'fail',\n          stackSubmission: {\n            enabled: Boolean(params.submit),\n            draft: false,\n            autoMerge: false,\n          },\n        });\n        await vcsEngine.initialize(workdir);\n\n        logger.info(\n          `Integrating ${params.tasks.length} task(s) into ${params.targetBranch}${params.submit ? ' with PR submission' : ''}`,\n        );\n\n        // Convert task parameters to ExecutionTask structure\n        const executionTasks = params.tasks.map((task) => ({\n          id: task.id,\n          name: task.name,\n          complexity: 'M' as const,\n          description: task.name,\n          files: [],\n          acceptanceCriteria: [],\n          dependencies: [],\n          maxRetries: 0,\n          retryCount: 0,\n          state: 'completed' as const,\n          stateHistory: [],\n          branchName: task.branchName ?? `task/${task.id}`,\n        }));\n\n        // Build stack from tasks\n        const result = await vcsEngine.buildStackFromTasks(executionTasks, workdir, {\n          parentRef: params.targetBranch,\n          submitStack: params.submit,\n        });\n\n        // Extract branch names from result\n        const branches = result.branches.map((b) => b.branchName);\n\n        logger.info('Stack integration completed', {\n          branches,\n          prUrls: result.prUrls,\n        });\n\n        return JSON.stringify({\n          status: 'success',\n          branches,\n          conflicts: [],\n          prUrls: result.prUrls ?? [],\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.error('integrate_task_stack failed', { error: errorMessage, tasks: params.tasks });\n\n        // Check for conflict indicators\n        const isConflict =\n          errorMessage.toLowerCase().includes('conflict') ||\n          errorMessage.toLowerCase().includes('merge') ||\n          errorMessage.toLowerCase().includes('rebase');\n\n        if (isConflict) {\n          // Provide conflict resolution guidance\n          const conflicts = params.tasks.map((task) => ({\n            taskId: task.id,\n            files: [],\n            resolution: `Fix conflicts in worktree .chopstack/shadows/${task.id}, then retry integration`,\n          }));\n\n          return JSON.stringify({\n            status: 'failed',\n            branches: params.tasks.map((t) => t.branchName ?? `task/${t.id}`),\n            conflicts,\n            error: `Integration failed due to merge conflicts in ${conflicts.length} task(s)`,\n          });\n        }\n\n        // Generic error response\n        return JSON.stringify({\n          status: 'failed',\n          branches: params.tasks.map((t) => t.branchName ?? `task/${t.id}`),\n          conflicts: [],\n          error: errorMessage,\n        });\n      }\n    },\n  });\n\n  // Tool 4: Cleanup task worktree\n  mcp.addTool({\n    name: 'cleanup_task_worktree',\n    description:\n      'Remove worktree after task completion. ' +\n      'Cleans up filesystem worktree directory and optionally deletes the branch. ' +\n      'Use keepBranch=true for git-spice stacks where branches should persist after integration.',\n    parameters: CleanupWorktreeSchema,\n    execute: async (params: CleanupWorktreeParams) => {\n      try {\n        logger.debug('cleanup_task_worktree called', { params });\n\n        // Get working directory (default to current directory)\n        const workdir = params.workdir ?? process.cwd();\n\n        // Create VCS engine service with default configuration\n        const vcsEngine = new VcsEngineServiceImpl({\n          branchPrefix: 'task',\n          shadowPath: '.chopstack/shadows',\n          cleanupOnSuccess: true,\n          cleanupOnFailure: false,\n          conflictStrategy: 'fail',\n          stackSubmission: {\n            enabled: false,\n            draft: false,\n            autoMerge: false,\n          },\n        });\n        await vcsEngine.initialize(workdir);\n\n        logger.info(`Cleaning up worktree for task ${params.taskId}`);\n\n        // Create a minimal worktree context for cleanup\n        // The cleanup method expects an array of WorktreeContext objects\n        const worktreeContext = {\n          taskId: params.taskId,\n          branchName: `task/${params.taskId}`,\n          worktreePath: `.chopstack/shadows/${params.taskId}`,\n          absolutePath: `${workdir}/.chopstack/shadows/${params.taskId}`,\n          baseRef: 'main', // Not used for cleanup\n          created: new Date(),\n        };\n\n        // Clean up the worktree\n        await vcsEngine.cleanupWorktrees([worktreeContext]);\n\n        // If keepBranch is false, we should delete the branch\n        // Note: The current implementation doesn't expose branch deletion directly,\n        // so we document that the branch cleanup needs manual handling or\n        // happens during stack integration\n        const branchDeleted = !params.keepBranch;\n\n        logger.info('Worktree cleanup completed', {\n          taskId: params.taskId,\n          branchDeleted,\n        });\n\n        return JSON.stringify({\n          status: 'success',\n          taskId: params.taskId,\n          cleaned: true,\n          branchDeleted,\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.error('cleanup_task_worktree failed', {\n          error: errorMessage,\n          taskId: params.taskId,\n        });\n\n        return JSON.stringify({\n          status: 'failed',\n          taskId: params.taskId,\n          cleaned: false,\n          error: errorMessage,\n        });\n      }\n    },\n  });\n\n  // Tool 5: List task worktrees\n  mcp.addTool({\n    name: 'list_task_worktrees',\n    description:\n      'List all active worktrees for repository. ' +\n      'Returns metadata for each worktree including task ID, paths, branch name, and status. ' +\n      'Use includeOrphaned=true to detect worktrees from crashed runs that need cleanup.',\n    parameters: ListWorktreesSchema,\n    execute: async (params: ListWorktreesParams) => {\n      try {\n        logger.debug('list_task_worktrees called', { params });\n\n        // Get working directory (default to current directory)\n        const workdir = params.workdir ?? process.cwd();\n\n        logger.info('Listing active worktrees');\n\n        // List worktrees by reading the git worktree list directly\n        // This provides a more direct implementation without needing to track state\n        const { GitWrapper } = await import('@/adapters/vcs/git-wrapper');\n        const git = new GitWrapper(workdir);\n\n        // Get all worktrees from git\n        const gitWorktrees = await git.listWorktrees();\n\n        // Filter to only chopstack worktrees (those in .chopstack/shadows)\n        const chopstackWorktrees = gitWorktrees.filter((wt) =>\n          wt.path.includes('.chopstack/shadows'),\n        );\n\n        // Map git worktrees to our response format\n        const worktrees = chopstackWorktrees.map((wt) => {\n          // Extract task ID from path (e.g., \".chopstack/shadows/task-1\" -> \"task-1\")\n          const pathParts = wt.path.split('/');\n          const taskId = pathParts.at(-1) ?? 'unknown';\n\n          return {\n            taskId,\n            path: wt.path,\n            absolutePath: wt.path,\n            branch: wt.branch ?? 'unknown',\n            baseRef: wt.head ?? 'unknown',\n            created: new Date().toISOString(), // Git doesn't track creation time\n            status: 'active' as const,\n          };\n        });\n\n        logger.info(`Found ${worktrees.length} active worktree(s)`);\n\n        return JSON.stringify({\n          status: 'success',\n          worktrees,\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.error('list_task_worktrees failed', { error: errorMessage });\n\n        return JSON.stringify({\n          status: 'failed',\n          error: errorMessage,\n        });\n      }\n    },\n  });\n}\n",
    "// MCP Server export for FastMCP\nimport { mcp } from './entry/mcp/server';\n\n// FastMCP expects a default export\n// eslint-disable-next-line import-x/no-default-export\nexport default mcp;\n"
  ],
  "mappings": "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",
  "debugId": "9462117F1AEA587464756E2164756E21",
  "names": []
}