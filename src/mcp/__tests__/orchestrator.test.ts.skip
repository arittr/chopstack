import { EventEmitter } from 'node:events';

import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

import type { ExecutionMode } from '@/types/execution';

import { TaskOrchestrator } from '@/mcp/orchestrator';

// Mock execa
vi.mock('execa');

// Create a mock ExecaChildProcess
function createMockProcess(overrides?: Partial<any>): any {
  const emitter = new EventEmitter();
  const stdoutEmitter = new EventEmitter();
  const stderrEmitter = new EventEmitter();

  const mockProcess = Object.assign(emitter, {
    stdout: stdoutEmitter,
    stderr: stderrEmitter,
    stdin: null,
    exitCode: null,
    signalCode: null,
    killed: false,
    pid: 12345,
    kill: vi.fn(() => true),
    // Add promise methods
    then: vi.fn(),
    catch: vi.fn(),
    finally: vi.fn(),
    cancel: vi.fn(),
    ...overrides,
  });

  return mockProcess;
}

describe('TaskOrchestrator', () => {
  let orchestrator: TaskOrchestrator;
  let mockExeca: any;

  beforeEach(async () => {
    vi.clearAllMocks();

    // Import execa and get the mock
    const execaModule = await import('execa');
    mockExeca = vi.mocked(execaModule.execa);

    orchestrator = new TaskOrchestrator();
  });

  afterEach(() => {
    // Clean up any running tasks
    for (const taskId of orchestrator.getRunningTasks()) {
      orchestrator.stopTask(taskId);
    }
  });

  describe('executeClaudeTask', () => {
    it('should execute a task successfully in plan mode', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-task-1',
        'Button Component',
        'Create a button component',
        ['Button.tsx'],
        '/test/project',
        'plan',
      );

      // Simulate successful execution
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Planning task execution...\n');
        mockProcess.stdout.emit('data', '{"files_changed": ["Button.tsx"]}\n');
        mockProcess.emit('close', 0);
      }, 10);

      const result = await resultPromise;

      expect(result.taskId).toBe('test-task-1');
      expect(result.status).toBe('completed');
      expect(result.filesChanged).toEqual(['Button.tsx']);
      expect(mockExeca).toHaveBeenCalledWith(
        'claude',
        ['-p', '--permission-mode', 'plan', '--output-format', 'json', expect.any(String)],
        expect.objectContaining({
          cwd: '/test/project',
        }),
      );
    });

    it('should execute a task successfully in execute mode', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-task-2',
        'Button Component',
        'Create a button component',
        [],
        '/test/project',
        'execute',
      );

      // Simulate successful execution
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Creating Button.tsx...\n');
        mockProcess.stdout.emit('data', 'created: src/Button.tsx\n');
        mockProcess.emit('close', 0);
      }, 10);

      const result = await resultPromise;

      expect(result.taskId).toBe('test-task-2');
      expect(result.status).toBe('completed');
      expect(result.filesChanged).toEqual(['src/Button.tsx']);
    });

    it('should handle task failure', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-task-fail',
        'Invalid Task',
        'Invalid task',
        [],
        '/test/project',
      );

      // Simulate failed execution
      setTimeout(() => {
        mockProcess.stderr.emit('data', 'Error: Task failed\n');
        mockProcess.emit('close', 1);
      }, 10);

      const result = await resultPromise;

      expect(result.taskId).toBe('test-task-fail');
      expect(result.status).toBe('failed');
      expect(result.error).toBe('Error: Task failed');
    });

    it('should handle task timeout', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      // Create orchestrator with short timeout for testing
      const shortTimeoutOrchestrator = new TaskOrchestrator();
      vi.spyOn(shortTimeoutOrchestrator as any, 'timeout').mockReturnValue(100); // 100ms timeout

      const resultPromise = shortTimeoutOrchestrator.executeClaudeTask(
        'test-task-timeout',
        'Long Task',
        'Long running task',
        [],
        '/test/project',
        'execute',
      );

      // Don't emit close event to simulate long-running task
      // Just wait for the promise to resolve with timeout
      await new Promise(resolve => setTimeout(resolve, 150));

      // Clean up by emitting close
      mockProcess.emit('close', 0);
      const result = await resultPromise;

      expect(result.taskId).toBe('test-task-timeout');
      expect(result.status).toBe('completed'); // Since we emit close with 0
    });

    it('should track task status while running', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-task-status',
        'Component',
        'Create component',
        [],
        '/test/project',
      );

      // Check status while running
      await new Promise((resolve) => setTimeout(resolve, 10));
      const runningStatus = orchestrator.getTaskStatus('test-task-status');
      expect(runningStatus).toBe('running');
      expect(orchestrator.getRunningTasks()).toContain('test-task-status');

      // Complete the task
      mockProcess.emit('close', 0);
      await resultPromise;

      // Check status after completion
      const completedStatus = orchestrator.getTaskStatus('test-task-status');
      expect(completedStatus).toBe('completed');
      expect(orchestrator.getRunningTasks()).not.toContain('test-task-status');
    });

    it('should capture task output', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-task-output',
        'Code Generation',
        'Generate code',
        [],
        '/test/project',
      );

      // Simulate output
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Line 1\n');
        mockProcess.stdout.emit('data', 'Line 2\n');
        mockProcess.stderr.emit('data', 'Warning: something\n');
        mockProcess.emit('close', 0);
      }, 10);

      const result = await resultPromise;

      expect(result.output).toContain('Line 1');
      expect(result.output).toContain('Line 2');
      expect(result.output).toContain('Warning: something');

      // Check output retrieval
      const output = orchestrator.getTaskOutput('test-task-output');
      expect(output).toContain('Line 1');
    });

    it('should handle validation mode', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-validate',
        'Validation',
        'Validate dependencies',
        [],
        '/test/project',
        'validate',
      );

      // Simulate validation with warnings
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'warning: Outdated dependency\n');
        mockProcess.stdout.emit('data', 'All validations passed\n');
        mockProcess.emit('close', 0);
      }, 10);

      const result = await resultPromise;

      expect(result.status).toBe('completed');
      expect(result.validationResults).toEqual({
        canProceed: true,
        errors: [],
        warnings: ['Outdated dependency'],
      });
    });

    it('should handle dry-run mode', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-dry-run',
        'Components',
        'Create components',
        [],
        '/test/project',
        'dry-run',
      );

      // Simulate dry-run output
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'would create: Button.tsx\n');
        mockProcess.stdout.emit('data', 'would modify: App.tsx\n');
        mockProcess.emit('close', 0);
      }, 10);

      const result = await resultPromise;

      expect(result.filesChanged).toEqual(['Button.tsx', 'App.tsx']);
    });
  });

  describe('stopTask', () => {
    it('should stop a running task', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-stop',
        'Long Task',
        'Long task',
        [],
        '/test/project',
      );

      // Wait for task to start
      await new Promise((resolve) => setTimeout(resolve, 10));

      // Stop the task
      const stopped = orchestrator.stopTask('test-stop');
      expect(stopped).toBe(true);
      expect(mockProcess.kill).toHaveBeenCalledWith('SIGTERM');

      // Simulate process termination
      mockProcess.emit('close', 143); // SIGTERM exit code

      const result = await resultPromise;
      expect(result.status).toBe('stopped');
    });

    it('should return false when stopping non-existent task', () => {
      const stopped = orchestrator.stopTask('non-existent');
      expect(stopped).toBe(false);
    });

    it('should handle process kill failure gracefully', async () => {
      const mockProcess = createMockProcess({
        kill: vi.fn(() => false), // Kill fails
      });
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-kill-fail',
        'Test Task',
        'Task',
        [],
        '/test/project',
      );

      // Wait for task to start
      await new Promise((resolve) => setTimeout(resolve, 10));

      // Try to stop the task
      const stopped = orchestrator.stopTask('test-kill-fail');
      expect(stopped).toBe(false);

      // Clean up
      mockProcess.emit('close', 0);
      await resultPromise;
    });
  });

  describe('getAllTaskStatuses', () => {
    it('should return all task statuses', async () => {
      const mockProcess1 = createMockProcess();
      const mockProcess2 = createMockProcess();

      mockExeca
        .mockReturnValueOnce(mockProcess1)
        .mockReturnValueOnce(mockProcess2);

      // Start two tasks
      const task1Promise = orchestrator.executeClaudeTask('task-1', 'Task 1', 'First task', [], '/test/project');
      const task2Promise = orchestrator.executeClaudeTask('task-2', 'Task 2', 'Second task', [], '/test/project');

      // Wait for tasks to start
      await new Promise((resolve) => setTimeout(resolve, 10));

      const allStatuses = orchestrator.getAllTaskStatuses();
      expect(allStatuses.size).toBe(2);
      expect(allStatuses.get('task-1')).toBe('running');
      expect(allStatuses.get('task-2')).toBe('running');

      // Complete tasks
      mockProcess1.emit('close', 0);
      mockProcess2.emit('close', 1);
      await Promise.all([task1Promise, task2Promise]);

      const finalStatuses = orchestrator.getAllTaskStatuses();
      expect(finalStatuses.get('task-1')).toBe('completed');
      expect(finalStatuses.get('task-2')).toBe('failed');
    });
  });

  describe('error handling', () => {
    it('should handle execa spawn errors', async () => {
      mockExeca.mockRejectedValue(new Error('Command not found: claude'));

      const result = await orchestrator.executeClaudeTask(
        'test-spawn-error',
        'Test Task',
        'Task',
        [],
        '/test/project',
      );

      expect(result.status).toBe('failed');
      expect(result.error).toContain('Command not found: claude');
    });

    it('should handle process crash', async () => {
      const mockProcess = createMockProcess();
      mockExeca.mockReturnValue(mockProcess);

      const resultPromise = orchestrator.executeClaudeTask(
        'test-crash',
        'Crash Test',
        'Crashing task',
        [],
        '/test/project',
      );

      // Simulate process crash
      setTimeout(() => {
        mockProcess.emit('error', new Error('Process crashed'));
        mockProcess.emit('close', -1);
      }, 10);

      const result = await resultPromise;

      expect(result.status).toBe('failed');
      expect(result.error).toContain('Process crashed');
    });

    it('should handle invalid mode gracefully', async () => {
      const result = await orchestrator.executeClaudeTask(
        'test-invalid-mode',
        'Invalid Mode Test',
        'Task',
        [],
        '/test/project',
        'invalid-mode' as ExecutionMode,
      );

      expect(result.status).toBe('failed');
      expect(result.error).toContain('Unsupported execution mode');
    });
  });

  describe('concurrent task execution', () => {
    it('should handle multiple concurrent tasks', async () => {
      const processes = [
        createMockProcess(),
        createMockProcess(),
        createMockProcess(),
      ];

      mockExeca
        .mockReturnValueOnce(processes[0])
        .mockReturnValueOnce(processes[1])
        .mockReturnValueOnce(processes[2]);

      // Start multiple tasks
      const tasks = [
        orchestrator.executeClaudeTask('concurrent-1', 'Task 1', 'First concurrent', [], '/test/project'),
        orchestrator.executeClaudeTask('concurrent-2', 'Task 2', 'Second concurrent', [], '/test/project'),
        orchestrator.executeClaudeTask('concurrent-3', 'Task 3', 'Third concurrent', [], '/test/project'),
      ];

      // Verify all are running
      await new Promise((resolve) => setTimeout(resolve, 10));
      expect(orchestrator.getRunningTasks()).toHaveLength(3);

      // Complete tasks with different outcomes
      processes[0].emit('close', 0);
      processes[1].emit('close', 1);
      processes[2].emit('close', 0);

      const results = await Promise.all(tasks);

      expect(results[0].status).toBe('completed');
      expect(results[1].status).toBe('failed');
      expect(results[2].status).toBe('completed');
      expect(orchestrator.getRunningTasks()).toHaveLength(0);
    });
  });
});